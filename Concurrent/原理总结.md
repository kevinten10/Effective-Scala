这个时候，一般会使用synchronized关键字来包装这个i，

或者觉得想对锁细粒度的操控，也可以使用lock包中的ReentrantLock类，这个类级别和synchronized一样，但是更灵活的对锁进行设置和操控

但是，从操作系统的角度来看，synchronized这种级别的锁相当于调用操作系统的mutex_lock，这就是相当于让当前线程放入内核中的等待队列中等待被唤醒

相当于有一个放弃cpu时间片休眠的过程，一直到对象的锁没有了，又被唤醒，抢到对象的锁，能抢到当前线程开始执行，抢不到继续休眠

上述的休眠-唤醒-休眠-唤醒 ... 的过程非常的耗时，效率很低，一般一次会错过几万个cpu时钟周期

而AtomicInteger 类就是java和cpu级别的CAS指令结合的典型案例，下面是两个程序的对比，差距惊人：

--------------

分析一下 AtomicInteger 类是怎么做的：



1.compareAndSet方法



典型的CAS的操作方法，调用JNI底层的cpu指令，

对于这部分的代码封装在sun的包中，并且根据不同cpu的特性，调用不同的JNI代码，

顾名思义，这个类也叫做unsafe

通过这个也可以发现，CAS并不是想象中的那么完美，在竞争压力极大的情况下，这种循环会消耗CPU大量的压力，导致cpu干不了正事

但CAS的操作，可比线程休眠，唤醒要强得太多太多，一个相当于在用户态一直没有出来，一个去到内核态进行排队再到用户态，二者的数量级不是一种；

CAS的锁也叫乐观锁，之所以乐观，就是因为他觉得压力没那么大，觉得一下子就可以拿到；

而get方法需要引起注意，为什么get方法可以获得最新的值呢？

其原因是value采用的是volatile，因为看到上述的多个方法都会调用这个get，这也就是为什么使用volatile的原因，保证可见性；


整体总结：

AtomicInteger 类的原理是 volatile + CAS；